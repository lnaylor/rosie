sp {block*non-simulated-ops
	(state <s> ^name evaluate-operator ^operator <o> +)
	(<o> -^simulated yes)
-->
	(<s> ^operator <o> -)}

sp {check-constraint*check-children*parent-candidates
	(state <s> ^constraint <c>)
	(<c> ^object <obj>)
	(<obj> ^candidate <cand>)
	-{(<obj> ^<child> ({ <=> <c> <some-child> } -^candidate-parent <cand>))
	-(<s> ^top-state.reserved-words.word <child>)}
-->
	(<obj> ^children-checked <cand>)}

sp {check*equalities
	(state <s> ^constraint <c>)
	(<c> ^object <obj>)
	(<obj> ^candidate <cand>)

	-(<c> ^object (^<link2> <obj> -^candidate))
	(<c> ^object (<par> ^<link> <obj>))
	(<par> -^candidate (<par-can> ^<link> <cand>) -^rejected <par-can>)
-->
	(<obj> ^rejected <cand>)}

sp {elaborate*counterpart*yes
	(state <s> ^impasse no-change ^attribute state ^evaluate-state <ss>)
	(<ss> ^name evaluate-operator ^constraint <c>)
	(<c> ^object <obj>)
	(<obj> ^candidate <cand> -^rejected <cand> ^children-checked <cand>)
-->
	(<obj> ^counterpart yes)}

sp {elaborate*counterpart*no
	(state <s> ^impasse no-change ^attribute state ^evaluate-state <ss>)
	(<ss> ^name evaluate-operator ^constraint <c>)
	(<c> ^object <obj>)
	-{(<obj> ^candidate <cand>)
	  (<obj> -^rejected <cand>)
	  (<obj> ^children-checked <cand>)}
-->
	(<obj> ^counterpart no)}

sp {elaborate*action*simulation*complete
	(state <s> ^evaluate-state <ss> ^impasse no-change ^attribute state ^superstate <super>)
	(<ss> ^action-operator <ao> ^copy-action <ca>)
	(<super> ^action-operator <ao>)
-->
	(<ss> ^action-completed yes)}

sp {elaborate*match*at-least*one*object
	(state <s> ^impasse no-change ^attribute state ^evaluate-state <ss>)
	(<ss> ^constraint <c> ^name evaluate-operator)
	(<c> ^object <obj>)
	-(<c> ^object (-^counterpart))
	-(<c> ^object (-^counterpart yes))
	-(<c> ^rules (^neq (-^neq-satisfied yes)))
-->
	(<c> ^violated yes)}

sp {elaborate*match*no-objects
	(state <s> ^impasse no-change ^attribute state ^evaluate-state <ss>)
	(<ss> ^name evaluate-operator)
	(<ss> ^constraint <c>)
	(<c> -^object <obj>)
	-{(<c> ^rules.<name> <anything>)
		-(<s> ^top-state.reserved-words.word <name>)
		(<ss> -^<name> <anything>)}
-->
	(<c> ^violated yes)}

sp {elaborate*success*at-least-one*object
	(state <s> ^impasse no-change ^attribute state ^evaluate-state <ss>)
	(<ss> ^constraint <c> ^action-completed yes)
	(<c> ^object <obj>)
	-(<c> ^object (-^counterpart))
	(<c> ^object (-^counterpart yes))
	-{(<ss> ^operator (<op> ^simulated yes) +)
		-(<ss> ^operator <op>)}
-->
	(<c> ^violated no)}

sp {elaborate*success*no*objects
	(state <s> ^impasse no-change ^attribute state ^evaluate-state <ss>)
	(<ss> ^constraint <c> ^action-completed yes)
	-(<c> ^object <obj>)
	(<c> ^rules.<name> <something>)
	-(<ss> ^<name> <something>)
	-{(<ss> ^operator (<op> ^simulated yes) +)
		-(<ss> ^operator <op>)}
-->
	(<c> ^violated no)}

sp {elaborate*success*with-neq
	(state <s> ^impasse no-change ^attribute state ^evaluate-state <ss>)
	(<ss> ^constraint <c> ^action-completed yes)
	-(<c> ^object (-^counterpart))
	(<c> ^rules (^neq (-^neq-satisfied yes)))
	-{(<ss> ^operator (<op> ^simulated yes) +)
		-(<ss> ^operator <op>)}
-->
	(<c> ^violated no)}
